# //-----------------/This module's name is 'player_class'/------------------//
# //-----------------/prev module is 'None'/-------------------------------//
# //--------/first,second,third,fourth : import module/--------------------//
# //--------/fifth,sixth : initializing variables/--------------------------//
# //--------/seventh,eighth,ninth : define/---------------------------------//
# //---------------------/Notice End/-----------------------------------------//


# first import pico2d
from pico2d import *
# second import game_framework - keyword 'as' is only use game_framework
import game_framework as gf
# third import next module

# fourth import need module
import math

# fifth initializing module variables(for using to any modul)

# sixth initializing global variables(for only using this module)
running = True
MAX_ROTATE_SPEED = 0.1




# seventh define class

class clPlayerBody:

    def __init__(self):
        self.pressing = False
        self.keyType = None
        self.image = load_image("../res/object/character/player_body_pix.png")
        self.cx, self.cy = 450, 450  # X & Y == center's X & Y this var is center position
        self.fw, self.bk = 0 , 0 # this var is distance to forward or back
        self.vx, self.vy = self.cx, self.cy + 100 # this var is vector x & y
        self.hp, self.speed = 10, 10.0  # state
        self.rad = 0.0
        #test
        self.tx, self.ty = 0, 0 #this var is transfrom x & y
        self.angle = 0.0
        self.pointer = load_image("../res/object/character/pointer.png")



        # loading state 에서 받자
        self.roImage = None  # image

    def draw(self):
        self.image.composite_draw(self.rad, "", self.cx, self.cy)
        self.pointer.draw(self.vx,self.vy)




    def update(self):
        distx = (self.vx - self.cx)
        disty = (self.vy - self.cy)
        if self.pressing == True:

            if self.keyType == SDLK_RIGHT:
                self.rad = math.pi * self.angle / 180.0
                self.angle -= MAX_ROTATE_SPEED

                cosq = math.cos(self.rad)
                sinq = math.sin(self.rad)

                self.vx -=self.cx
                self.vy -=self.cy

                self.tx = self.vx * cosq - self.vy * sinq
                self.ty = self.vy * cosq + self.vx * sinq

                self.tx += self.cx
                self.ty += self.cy

                self.vx = self.tx
                self.vy = self.ty

            if self.keyType == SDLK_LEFT:
               self.angle +=MAX_ROTATE_SPEED

               self.rad = math.pi * self.angle / 180.0

               cosq = math.cos(self.rad)
               sinq = math.sin(self.rad)

               self.vx -= self.cx
               self.vy -= self.cy

               self.tx = self.vx * cosq + self.vy * sinq
               self.ty = self.vy * cosq - self.vx * sinq

               self.tx += self.cx
               self.ty += self.cy

               self.vx = self.tx
               self.vy = self.ty




                # dir == left
            if self.keyType == SDLK_UP:
                self.pressing = False

            if self.keyType == SDLK_DOWN:
                self.bk -=1






    # def handle_event(self):
    #   pass


# eighth define function

# ninth redefine game_framework's function
def enter():
    global player
    player = clPlayerBody()


def exit():
    pass


def draw():
    global player
    clear_canvas()
    # 여기부분 없애기
    player.draw()

    update_canvas()
    # 여기부분 없애기 어차피 stage에서 모두 클리어후에 작업할것이기 때문에


def update():
    global player
    player.update()


def handle_events():
    global player
    events = get_events()
    for event in events:
        if event.type == SDL_QUIT:
            gf.quit()
        if event.type == SDL_KEYDOWN:
            player.pressing = True
            player.keyType = event.key
            # 왜 끊키는가? 왜 끝까지 가지 못하는가?
        if event.type == SDL_KEYUP:
            player.keyType = None
            player.pressing = False


def pause():
    pass


def resume():
    pass


# start to this module

if __name__ == '__main__':
    import sys

    glCurrentModule = sys.modules[__name__]
    open_canvas()
    gf.run(glCurrentModule)
    close_canvas()

